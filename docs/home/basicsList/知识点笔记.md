---
title: 知识点笔记
sidebar: auto
date: '2020-07-05'
tag: # 页面的标签 
  - Javascript
# 一些 meta 标签, 可以用于被搜索引擎爬取
meta:
  - name: description
    content: 知识点笔记 Javascript CSS HTML
  - name: keywords # keywords 标签, 在页内搜索时会被查询
    content: 知识点笔记 记一些面试中可能问到的知识
prev: ./CSS笔记
# next: 
---

# 知识点笔记
主要记一些面试中可能问到的知识，本篇主要记基础部分的内容，分为HTML、CSS、Javascript、Vue、React相关知识点，在各自模块内也有相关基础知识

## HTML
### `<!DOCTYPE>`的作用？标准模式和兼容模式的区别？  
1. `<!DOCTYPE>`声明位于HTML文档中的第一行，处于`<thml>`标签之前，告知浏览器解析器以什么文档标准解析这个文档。`<!DOCTYPE>`不存在或者格式不正确会导致文档以兼容模式显示
2. 标准模式的排版和JS运作模式都是以浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示

### HTML5为什么只需要写`<!DOCTYPE>`  
HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为；HTML4基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型

### 行内元素有哪些？块级元素有哪些？空元素有哪些？  
行内元素：`a`,`span`,`img`,`input`,`select`, `strong`(代表强烈的重要性,字符使用粗体表现), `b`(粗体，无语义), `em`(强调), `i`(斜体，无语义)   
块级元素：`div, p, ol, ul, dl, dt, dd, h1-h6, article, section, nav, header, footer`  
常见的空元素：`<br>, <hr>（在 HTML 页面中创建一条水平线）, <link>, <meta>`

### 页面导入样式时，使用link和@import有什么区别  
1. `link`是HTML提供的标签，不仅可以加载CSS文件还可以定义RSS、rel等属性，`@import`是CSS提供的语法规则，只有导入样式表的作用
2. `link`引入的CSS被同时加载；`@import`引入的CSS将在页面加载完成之后加载
3. 可以通过JS操作`DOM`插入`link`标签，无法使用`@import`的方式插入样式
- 常用兼任性问题
  - 浏览器默认的margin和padding不同。解决方法使用通配符选择器设置margin、padding为0,`* {margin:0;padding:0;}`
  - Chrome中文界面下默认将小于12px的文本强制按照12px显示，可通过加入css属性`-webkit-text-size-adjust:none;`解决
  - 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不具有hover和active。解决办法是改变CSS属性的排列顺序：`L-V-H-A(a:link {} a:visited {} a:hover {} a:active {})`

### HTML5新特性    
增加绘画canvas，媒体标签video、audio，本地存储localStorage,sessionStorage  
语义化标签，article、header、footer、nav、section  
表单控件，calendar、date、time、email、url、search
新技术，webworker、websocket

### iframe的缺点和解决方法  
- iframe会阻塞主页面的onload事件，搜索引擎无法读取这种页面，不利于SEO优化
- iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面并行下载
- 可以绕开以上两个问题。如果需要使用iframe，通过JavaScript动态给iframe添加src属性值

### 如何关闭form表单自动完成功能  
自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。  
关闭此功能方式：给不想要提示的form或下的某个input设置`autocomplete=off`

### cookie,sessionStorage,localStorage的区别  
cookie在浏览器和服务器之间来回传递，sessionStorage 和 localStorage 存储在客户端；  
cookie 有个数和大小的限制，大小一般是4k，sessionStorage, localStorage 的存储空间更大，大约在5MB；
sessionStorage 存储的数据，浏览器关闭时会删除， localStorage 存储的数据，没有时间限制，除非主动删除

### 同一浏览器多个标签页之间的通信
使用 localStorage 、 cookie 等本地存储方式；

1. 使用 localStorage ，只能实现同一浏览器相同域名、相同协议、相同端口下的多个标签页之间的通信。不同浏览器没有该效果。

实现原理：localStorage 是 Storage 对象的实例。对 Storage 对象进行任何修改，都会在文档上触发 storage 事件。当通过属性或 setItem() 方法保存数据，使用 delete 操作符或 removeItem() 删除数据，或 clear() 方法时，都会触发这个事件，事件的 event 对象有以下属性：
- domin，发生变化的存储空间的域名
- key， 设置或删除的键名
- newValue，如果设置值为新值，如果删除值为 null 
- oldValue，键被更改前的值

``` js
// a页面
window.onload = function() {
  localStorage.setItem("test","testVal");
}

// b页面
window.addEventListener('storage',function(event) {
  console.log("getItem： "+localStorage.getItem("test"));
  console.log("Key： "+event.key);
  console.log("newValue： "+event.newValue);
  console.log("oldValue： "+event.oldValue);
})
```

2. cookie + setInterval

#### cookie 简介：
HTTP Cookie ，简称 cookie ，用于在客户端和服务端传递会话信息。该标准要求服务器对任意HTTP请求发送 Set-Cookie 请求头作为响应的一部分，其中包含会话信息。一般由服务端生成，可以设置失效时间。如果在浏览器生成 Cookie ，默认是关闭浏览器失效，每次都会携带在HTTP请求头中，最多只能存储4K左右的内容，原生 Cookie 接口不友好，需要自己封装。

例，cookie格式：`Set-Cookie: "name=value;domain=.test.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure"`

#### cookie 实现同一浏览器多个标签页之间通信的原理：
cookie的path：一个页面产生的 cookie ，只能被与这个页面的同一目录或者其子目录下的页面访问。因此，通常把cookie的path设置为一个更高级别的目录，从而使更多的页面共享cookie，实现多页面之间相互通信。

### 实时信息获取
实时类信息获取，一般会有4种方案：  
1. 轮询,使用定时器，客户端定时向服务端发送ajax请求，服务器接到请求立即返回响应信息并关闭连接。基于HTTP协议

2. 长轮询（Comet），http1.1支持由浏览器发起长轮询，客户端向服务器发送ajax请求，服务器接收到请求等到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。

3. websocket，浏览器与服务器建立websocket连接，双向通信

4. SSE（Server-Sent Events）
  - 基于HTTP的HTML5新特性，服务器推送，半双工
  - 浏览器向服务器发送一个HTTP请求，然后服务器不断单向地向浏览器推送“信息”（message）。这种信息在格式上很简单、固定，就是“信息”加上前缀“data: ”，然后以“\n\n”结尾。
  - 后端响应需加入头信息：`response.headers["Content-Type"] = "text/event-stream"`

### websocket实现原理，为什么可以实时通信（双向通信）
- websocket是一种网络通信协议，建立在TCP协议上，服务端实现比较容易。
- 与HTTP协议有良好的兼容性
- 数据格式比较轻量，性能开销小，通信效率高
- 可以发送文本，也可以发送二进制文件
- 没有同源限制，客户端可以与任何服务器通信
- 协议标识是`ws`,如果加密，则为`wss`
- Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手

::: tip HTTP实现长连接
在没有websocket之前，要做到长连接使用HTTP轮询技术：每隔一段时间发送一个请求，缺点是效率低，浪费资源和带宽
:::
[参考](https://segmentfault.com/a/1190000021074946)
[参考:阮一峰](http://www.ruanyifeng.com/blog/2017/05/websocket.html)

### WebSocket 如何兼容低版本浏览器  
Adobe Flash Socket、ActiveX HTMLFile(IE)、基于multipart编码发送XHR、基于长轮询的XHR

### `img`的 title 和 alt 的区别
- `title` 鼠标滑过时显示的文字提示，用来增强用户体验
- `alt` 是`img`特有的属性，是图片无法显示的时候作为替换的文本

### `src` 和 `href` 的区别
- 一般加载`script`使用src,放在body下面，加载`CSS`使用href，放在`head`里面
- src用于替换当前元素，href用于在当前元素和引用资源之间确立关系。
- src是`source`的缩写，指定外部资源的位置，指定的内容会下载并应用到文档中，会嵌入文档中当前标签的位置
::: tip 例
`<script src="./common.js"></script>` 当浏览器解析到这个元素的时候，会阻塞其他资源的下载和处理，直到当前资源加载、编译、执行完毕，图片和`iframe`等元素类似，这就是`script`标签放到页面底部的原因 
:::

- herf是`Hypertext Reference`的缩写，指定网络资源的位置、建立当前元素（锚点）和当前文档（链接）之间的链接。
::: tip 例
`<link href="common.css"></link>` 浏览器会识别当前文档为CSS文件，会进行并行下载，不会停止对当前文档的加载。这也是`link`标签放在头部，使用`link`而不使用`@import`的原因
:::

### 简单介绍 HTTP 的请求方法
HTTP是超文本传输协议，定义了客户端和服务端文本传输的规范。HTTP默认使用80端口，这个端口指的是服务端的端口，客户端使用的端口是动态分配的。
HTTP/1.1 协议中定义了 8种 方法，HTTP1.0 定义了三种请求方法，`GET`,`POST`,`HEAD`,HTTP1.1增加了五种请求方法，`OPTIONS`,`PUT`,`DELETE`,`TRACE`,`CONNECT`

**GET**  
向特定的资源发出请求。

**POST**  
向指定的资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。

**PUT**  
向指定资源位置上传最新的内容

**DELETE**  
请求服务器删除指定的资源

**TRACE**  
回显服务器收到的请求，主要用于测试或诊断

**CONNECT**  
HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

**OPTIONS**  
返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向Web服务器发送`*`的请求来测试服务器的功能性

### HTTP请求/响应的步骤
1. 客户端连接到Web服务器
2. 发送HTTP请求
3. 服务器接受请求并返回HTTP响应
4. 释放连接的TCP连接
5. 客户端浏览器解析HTML内容

### HTTP请求 Request
客户端发送HTTP请求到服务器包含4个部分：请求行（request line）、请求头（header）、空行、请求体

例：
``` txt
POST /api/gameCustomer/customer/auth HTTP/1.1
Host: localhost:8013
Connection: keep-alive
Content-Length: 375
Accept: application/json, text/plain, */*

{"id":6,"companyId":6,"createTime":1577512305900,"email":"123@qq.com"}

第一部分：请求行，第一行明了是post请求，以及http1.1版本。
第二部分：请求头部，第二行至第六行。
第三部分：空行，第七行的空行。
第四部分：请求数据，第八行。
```

### HTTP 状态码
- `100` Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
- `200` OK 当您的操作将在响应正文中返回数据时，出现此结果。
- `204` No Content 当您的操作成功，但不在响应正文中返回数据时，出现此结果。
- `304` Not Modified (重定向)当测试实体自上次检索以来是否被修改时，出现此结果。
- `400` BadRequest（客户端错误） 当参数无效时，出现此结果。
- `401` Unauthorized 客户端错误
- `403` Forbidden   客户端错误
- `404` Not Found（客户端错误） 当资源不存在时，出现此结果。
- `405` Method Not Allowed（客户端错误）由于方法和资源组合不正确而出现此错误。 例如，您不能对一个实体集合使用 DELETE 或 PATCH。
- `413` Payload Too Large（客户端错误） 当请求长度过长时，出现此结果。
- `412` Precondition Failed  客户端错误
- `501` Not Implemented（服务器错误） 当未实施某个请求的操作时，出现此结果。
- `503` Service Unavailable（服务器错误） 当 Web API 服务不可用时，出现此结果。

### GET 与 POST的区别
- HTTP协议最常见的两种方法
- GET在浏览器中后退是无害的，POST会再次提交请求
- GET会被浏览器主动缓存，POST不会，除非手动设置
- GET产生的URL可以收藏书签，POST不可以
- GET请求的参数会被完整保留在浏览器历史记录里，POST中的参数不会被保留
- GET请求在URL中传参有长度限制（各个浏览器的长度限制不同，chrome最大长度限制为8182个字符），POST没有
- 参数的编码，GET只支持ASCII码，POST没有限制
- GET参数通过URL传递，跟在URL后面，POST参数包含在请求体中

### Canvas 和 SVG 的区别
- SVG 输出的是矢量图形，不会出现失真，Canvas输出的是画布，是位图，放大到一定程度会失真。
- SVG 绘制出来的每个图形元素都是一个DOM节点，能够随时修改和绑定事件。Canvas 输出的是一整张画布。



## CSS
### 盒子模型
页面渲染时，DOM元素所采用的布局模型。包含内容区、内边距、边框、外边距。

### IE盒子和标准W3C盒子模型区别  
  - IE的内容区(content)部分包含了border和padding

### CSS选择器有哪些？  
- ID选择器
- 类选择器
- 标签选择器
- 相邻选择器
- 子选择器
- 后代选择器
- 通配符选择器
- 属性选择器
- 伪类选择器

### 可继承的样式  
font-size,font-family,color,line-height,visibility

### 不可继承的样式  
border,padding,margin,width,height

### CSS标签权重和优先级如何计算  
- 权重的规则：标签的权重为1，class的权重为10，id的权重为100
- 就近原则，同权重情况下样式定义最近者为准
- 载入样式以最后载入的定位为准
- !important > 行内样式 > id > class > tag

### CSS3新增哪些伪类？  
``` css
p:first-of-type /*选择属于其父元素的首个 <p> 元素的每个 <p> 元素*/
p:last-of-type /*选择属于其父元素的最后一个 <p> 元素的每个 <p> 元素*/
p:only-of-type /*选择属于其父元素唯一的 <p> 元素的每个 <p> 元素*/
p:only-child /*选择属于其父元素的唯一子元素的每个 <p> 元素*/
p:nth-child(2) /*选择属于其父元素的第二个子元素的每个 <p> 元素*/
:enabled /*匹配每个启用的元素*/
:disabled /*选择器匹配每个禁用的的元素（主要用于表单元素）*/
:checked /*单选框或复选框被选中*/
```

### rgba() 和 opacity 的透明效果的区别  
  - rgba() 和 opacity 都能实现透明效果，opacity作用于元素，和元素内所有内容的透明度
  - rgba() 只作用于元素的颜色或者背景色，设置rgba透明的元素的子元素不会继承透明效果

### CSS3新特性  
圆角(border-radius)，阴影(box-shadow)，文字阴影(text-shadow)，线性渐变(linear-gradient)，径向渐变(radial-gradient)，动画(transform,animate)

### 为什么要初始化CSS样式  
  - 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的

### 解释下浮动和它的工作原理？清除浮动的技巧  
浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。  
  1. 使用空标签清除浮动。在浮动标签的后面加一个空标签，设置css clear:both，弊端是增加了无意义标签
  2. 使用overflow。给包含浮动元素的父标签添加css overflow:hideen;
  3. 使用after伪元素清除浮动。该方法中必须为需要清除浮动元素的伪元素中设置 height:0，否则该元素会比实际高出若干像素；
  4. 父元素也使用浮动。

### display的值和作用  
- `display: block;` 块状元素
- `display: inline;` 行内元素
- `display: inline-block;` 行内块状元素
- `display: list-item;` 列表元素，设置过后跟 ul、ol 的显示一样
- `display: table;` 表格
- `display: inherit;` 从父元素继承 display 属性的值
- `display: none;` 元素不可见

### `display:inline-block`会产生间隙,解决办法  
- 父元素中设置`font-size:0;letter-spaceing:-4px;`,`letter-spacing`负值可以去除所有浏览器的换行符间隙

- HTML元素首尾相连

### `display: none;`和`visibility: hidden;`的区别  
- 效果都是让元素不可见
- `display: none;` 会让元素完全从渲染树中消失，渲染时不占据空间；`visibility: hidden;`不会让元素从渲染树消失，会继续占用空间，只是内容不可见
- `display: none;`是非继承属性，`visibility: hidden;`是继承属性，子孙元素通过设置`visibility: visible;`显示
- 读屏器不会读取`display: none;`元素内容；会读取`visibility: hidden;`元素内容

### base64 图片的优缺点
- 优点，减少HTTP请求
- 需要消耗 CPU 编解码

### 伪类和伪元素的区别
- 伪类配合CSS选择器使用，选择不同状态的CSS元素
- 伪元素是真的有元素
- 使用伪类时用单冒号，伪元素用双冒号

### `::before` 和 `:before`中双冒号和单冒号有什么区别  
- 用来区分伪类和伪元素
- 单冒号(`:`) 用于CSS3伪类选择器，双冒号(`::`)用于伪元素

### 清除浮动
- 添加尾元素清除浮动
- 使用 伪元素，配合 clear: both
- 浮动父元素
- 父级元素设置高度

### SASS预处理器特性  
  1. 使用变量，变量声明（使用`$`符合标识变量）、变量引用(凡是CSS属性的标准值可存在的地方，变量就可以使用)、变量名用中划线声明的变量可以使用下划线的方式引用，反之亦然
  2. 嵌套规则，父容器选择符&
  3. 导入SASS文件，`@import`导入其他的SASS文件，sass允许`@import`命令写在css规则内，可以省略.sass或.scss文件后缀
  4. 混合器和选择器继承，混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复；继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。

### rem
rem是一个相对单位，相对根元素字体大小的单位。我们只需要指定根元素为参考值，就可以了。主要用于屏幕适配布局，移动端使用比较广泛。使用这种方式，只要根据不同屏幕设置不同的根元素即可使系统适配不同的屏幕。

### 居中浮动元素  
``` css
.div {
  position: relative;
  left: 50%;
  top: 50%;
  margin: -150px 0 0 -250px;
  width: 500px;
  height: 300px;
}
```

### 水平居中
- 元素为行内元素，设置父级 `text-align: center`
- 如果元素宽度固定，设置左右margin 为 auto
- 如果元素为绝对定位，设置父元素 position: relative; 元素设置left: 0;right: 0;margin: auto;
- 使用flex布局，设置 justify-content: center

### 垂直居中
- 设置元素样式 `display: table-cell;vertical-align: middle;`
- 使用flex布局，设置 `align-items: center;`
- 绝对定位元素设置 `bottom: 0;top: 0;margin: auto;`
- 绝对定位元素固定高度，设置 `top: 50%;` ,margin-top 为高度一半的负值
- 文本内容垂直居中，设置 line-height 为 height 的值，使用百分比无效

### CSS实现DIV的水平、垂直居中
1. 父元素使用`display: table;`，`vertical-align: middle;`，子元素`display: table-cell;`，margin 配置左右 auto

2. 绝对定位方式，父元素设置定位`position: relative | absolute | fixed`，子元素设置绝对定位`position: absolute;left: 50%;top: 50%;transform: translate(-50%,-50%)`

3. 绝对定位方式，父元素设置定位`position: relative | absolute | fixed`，子元素固定宽高，设置绝对定位`position: absolute;left: 50%;top: 50%;`，margin-left , margin-top 设置负的一半宽高

4. 绝对定位方式，父元素设置定位`position: relative | absolute | fixed`，子元素固定宽高，设置绝对定位`position: absolute;margin: auto;left: 0;right: 0;top: 0;bottom: 0;`

5. flex布局，父级元素设置`display: flex;justify-content: center;align-items: center`

### flex 多列布局
1. 两列两行布局：
``` html
<div class="box">
  <div class="column">
    <span class="item"></span>
    <span class="item"></span>
  </div>
  <div class="column">
    <span class="item"></span>
    <span class="item"></span>
  </div>
</div>
```
``` css
.box {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
}
.column: {
  flex-basis: 100%;
  display: flex;
  justify-content: space-between;
}
```

2. 四项目
``` html
<div class="box">
  <div class="column">
    <span class="item"></span>
    <span class="item"></span>
  </div>
  <div class="column">
    <span class="item"></span>
    <span class="item"></span>
  </div>
</div>
```
``` css
.box {
  display: flex;
  flex-wrap: wrap;
  align-content: space-between;
}
.columu {
  flex-basis: 100%;
  display: flex;
  justify-content: space-between;
}
```

3. 六项目
``` html
<div class="box">
  <div class="column">
    <span class="item"></span>
    <span class="item"></span>
    <span class="item"></span>
  </div>
  <div class="column">
    <span class="item"></span>
    <span class="item"></span>
    <span class="item"></span>
  </div>
</div>
```
``` css
/* 两行三列 */
.box {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
}

.column {
  flex-basis: 100%;
  display: flex;
  justify-content: space-between;
}

/* 如果不改变HTML布局，变成三行两列，使用flex-direction: column; */
/* 三行两列 */
.box {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
}

.column {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
```

### 不太记得的flex属性
- flex-grow,定义项目放大比例，默认为0，即如果存在剩余空间也不放大；如果所有的项目的 flex-grow 都为1，则它们将等分剩余空间。如果其中一个项目的 flex-grow 为2，其他项目都为1，则前者占据的剩余空间比其他的多一倍。

- flex-shrink,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小；如果所有项目的 flex-shrink 都为1，当空间不足时，都将等比例缩小；如果一个项目的 flex-shrink 属性为0，其他项目都为1，当空间不足时，前者不缩小。

- flex-basis，定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。默认值为auto，即项目本来的大小。

- flex，属性是 flex-grow,flex-shrink,flex-basis 的简写，默认值为 `0 1 auto`。后两个属性可选。这个属性有两个快捷值：
  - auto （1 1 auto）
  - none （0 0 auto）

优先使用 flex 的简写形式，而不是单独写三个分离的属性，因为浏览器会推算相关值。

## PostCSS
PostCSS 是一个用Javascript工具和插件转换CSS代码的工具。类似babel对js的处理

常见特性：
- 自动补全浏览器前缀
- 转换新一代的CSS语法
- 模块化CSS
- 语法检测
- 代码格式化
- 压缩

PostCSS只是一款使用插件转换CSS的工具，通过插件实现功能，例如：`autoprofixer`,`cssnext`,`postcss-pxtorem`,`CSS Modules`等

### 在Webpack中使用
- 安装 `postcss-loader`
`yarn add postcss-loader --dev`

- 在webpack.config.js 中 使用 `postcss-loader`
``` js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        exclude: /node_modules/,
        use: [
          {
            loader: 'style-loader',
          },
          {
            loader: 'css-loader',
            options: {
              importLoaders: 1,
            }
          },
          {
            loader: 'postcss-loader'
          }
        ]
      }
    ]
  }
}
```

- 创建 `postcss.config.js`
```
module.exports = {
  plugins: [
    require('precss'),
    require('autoprefixer')
  ]
}
```

## JavaScript
### jQuery `$(document).ready()` 和 `load()` 的区别
jQuery的 `ready()`方法监听的是 `DOMContentLoaded`事件，是DOM加载完之后执行；`load()`方法是指`window.onload`事件，会等到DOM、图片等所有的资源加载完毕再执行。

### Javascript作用域，作用域链  
- ES5 只有全局作用域和函数作用域
- ES6 增加了局部作用变量，`let`,`const`等具有局部作用域特性，不会出现变量提升的问题
- 作用域链是指作用域中访问变量和函数的环境，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的
- 作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期

### 实例、构造函数、原型的关系
每创建一个函数，该函数就会自动带一个 prototype 属性。该属性是一个指针，指向一个对象，称之为 原型对象。

原型对象上默认有个 constructor 属性，该属性也是一个指针，指向相关联的构造函数。

通过调用构造函数产生的实例，都有一个`__proto__`内部属性，指向原型对象。所以实例能够访问原型对象上的所有属性和方法。

所以三者的关系是，每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针（constructor），而实例都包含一个指向原型的内部指针。通俗点说就是，实例通过内部指针 (`__proto__`) 可以访问到原型对象，原型对象通过 constructor 指针，又可以找到构造函数。

### 原型链
访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype ，于是就这样一直找下去，一直检索到 Object 内建对象，也就是我们平时所说的原型链的概念。

通过重写构造函数的 prototype 指向的原型对象，改变实例内部指针，指向新的原型对象，然后就能实现类与类的继承。

### Javascript实现继承的方式  
  - 原型式继承，在object函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例
  - 原型链（定义在prototype上的属性、方法），存在的问题，原型中包含引用类型值的问题
  - 构造器函数（在子类构造函数的内部调用父类构造函数，可以借助apply()和call()方法来改变对象的执行上下文），存在的问题，方法都在构造函数中定义，因此函数无法达到复用
  - 组合继承(原型链+构造函数)，使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承
  - `Object.create()`方法，可以接受两个参数，一个是用作新对象原型的对象和一个可选的为新对象定义额外属性的对象
  - 寄生式继承，创建一个仅用于封装继承过程的函数
  - 寄生组合式继承，借用构造函数来继承属性，通过原型链的混成形式来继承方法

### 事件模型  
**监听函数**  
浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到这个事件，会执行对应的监听函数。这就是事件驱动模式的主要编程方式。

绑定事件的三种方式：

1. HTML属性，HTML语言允许在元素的属性中，直接定义某些事件的监听代码。违反了HTML 与 Javascript 代码相分离的原则，将它们写在了一起，不利于代码分工。
``` html
<button onclick="alert('button')">alertButton</button>
```
2. js 元素节点对象的事件属性，指定监听函数。一个事件只能定义一个监听函数，如果定义多次 onclick 属性，后一次会覆盖前一次。

例：`document.getElementsByTagName('button').onclick = alert('alertButton2')`

3. `EventTaget.addEventListener(type,listener[,options])`（事件监听）

第三个参数可以设置为一个Boolean值（默认 flase，使用事件冒泡），或为 Object 类型的 options

options包含三个布尔值选项：
  - capture： 是否使用事件捕获，默认值为 false（使用事件冒泡）
  - once：是否只调用一次，默认值为 false，设置 true 会在调用之后自动销毁 listener
  - passive：默认值为 false，设置为 true，意味着listener永远不远调用preventDefault方法

所有的DOM节点实例都有 addEventListener 方法，用来为该节点定义事件监听函数。


  - 同一个事件可以添加多个监听函数
  - 能够指定在哪个阶段（捕获阶段/冒泡阶段）触发监听函数
  - 除了DOM节点，其他对象（比如 window,XMLHttpRequerst等）都有这个接口，它等于是整个 Javascript 统一的监听函数接口

**事件传播**  
一个事件发生后，会在子元素和父元素之间传播。这种传播分为三个阶段，捕获阶段（capturing）、目标阶段（targetin）、冒泡阶段（bubbling）

- 第一阶段：从 window 对象传播到目标节点（上层传到底层），称为“捕获阶段”
- 第二阶段：在目标节点上触发，称为“目标阶段”
- 第三阶段：从目标节点传播到 window 对象（从底层传到上层），称为“冒泡阶段”。

这种三阶段的传播模型，使得同一个事件会在多个节点触发。

事件传播的最上层对象是 window > document > html（document.documentElement） > body（document.body）

在捕获阶段依次是 window、document、html、body 然后是具体的DOM元素

在冒泡阶段依次是 具体的DOM元素、body、html、document、window

**事件代理**  
事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数绑定到父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件代理。

- 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发

- 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发

- DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件

- 阻止冒泡（阻止事件向上传播）：在W3c中，使用stopPropagation()方法；在IE下设置cancelBubble = true

- 阻止捕获（阻止事件向下传播）：阻止事件的默认行为，例如click - `<a>`后的跳转。在W3c中，使用`preventDefault()`方法，在IE下设置`window.event.returnValue = false`

- `event.stopImmediatePropagation()` 方法可以彻底取消这个事件，使得后面绑定的所有监听函数不再触发。

### eval是做什么的  
它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）

### null，undefined 的区别
Javascript的最初版本设计区分是：null 是一个表示“无”的对象，转为数值时是 0； undefined 是一个表示“无”的原始值，转为数值时为 NaN。

目前 null 和 undefined 基本同义，只有细微的差别；
- null 表示“没有对象”，即该处不应该有值
  - 作为函数的参数，表示该函数的参数不是对象
  - 作为对象原型链的终点

- undefined 表示“缺少值”，就是此处应该有一个值，但是还没有定义
  - 变量被声明了，但是没有赋值时，就等于 undefined
  - 调用函数时，应该提供的参数没有提供，该参数等于 undefined
  - 对象没有赋值的属性，该属性的值为 undefined
  - 函数没有返回值时，默认返回 undefined

### Node.js适用场景  
高并发、聊天、实时消息推送

### js数据类型  
基础类型：`String、Number、Boolean、Symbol,undefined,null`
引用类型：`Object、Function、Array、RegExp、Date` 等

### ["1","2","3"].map(parseInt)答案是多少  
[1,NaN,NaN] 因为parseInt需要两个参数(val,radix),radix表示解析时的基数。map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。

### 如何创建一个对象? （画出此对象的内存图）  
- 对象字面量 `{}`
- `Object.create()`
- 构造函数

### js中`break`,`continue`,`return`的区别
- 在三个关键字中，`break`,`continue`是化作一类的，`return`是函数返回语句，但返回的同时也能将函数停止；
- 三个都会将此时进行的语句停止。
- break是立即结束并跳出语句，进行下个语句执行
- continue是停止当前语句，进入下个循环
- return用于指定函数返回的值

### 什么是闭包（closure），为什么要用它  
- 闭包就是能够读取其他函数内部变量的函数，如果一个函数用到了它作用域外面的变量，那么这个变量和这个函数之间的环境就叫闭包；
- 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包最常见的方式就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域；
- 特点
  - 函数内再嵌套函数
  - 内部函数可以引用外层的参数和变量
  - 封装私有变量。把函数当作一个范围，函数内部的变量就是私有变量，在外部无法引用，但是我们可以通过闭包的特点来访问私有变量。
  - 存储变量。保存外部函数的变量，内部函数保留了对外部函数的活动变量的引用，变量始终保持在内存中。
  - 模仿块级作用域。

### 对闭包的理解  
- 使用闭包主要为了设计私有变量、方法。优点闭包可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存的使用量，使用不当容易造成内存泄漏。
- 能够实现封装和缓存，由于闭包会使函数中的变量保存在内存中，内存消耗大，使用不当会造成内存溢出。解决办法是，在退出函数前，将不使用的变量删除。

### 如何通过JS判断一个数组
- instanceof，用来测试一个对象是否在其原型链原型构造函数的属性
``` js
var arr = []
arr instanceof Array; // true
```

- constructor，返回对创建此对象的数组函数的引用，就是返回对象的构造函数
``` js
var arr = []
arr.constrcuctor === Array; //true
```

- Object.prototype.toString.call(val),判断对象的类型
``` js
var arr = []
Object.prototype.toString.call(arr).slice(8,-1); // Array
```

- isArray()方法
``` js
Array.isArray([]) // true
Array.isArray({}) // false
```

### 异步编程的实现方式
- 回调函数
  - 优点：简单、容易理解
  - 缺点：不利于维护，代码耦合度高

- 事件监听（使用事件驱动模式，取决某个事件是否发生）
  - 优点：可以绑定多个事件，每个事件可以指定多个回调函数
  - 缺点：事件驱动，流程不够清晰

- 发布者/订阅者模式（观察者模式）
  - 类似事件监听

- Promise 对象
  - 可以利用 then 方法，使用链式写法，可以写错误时的回调函数

- Generator 函数
  - 优点：函数体内网的数据交换、错误处理机制
  - 缺点：流程管理不方便

- async 函数
  - 内置执行器、更好的语义、更广的适用性，返回Promise对象，结构清晰

### `use strict`是什么  
通过严格模式，在函数内部选择进行较为严格的全局或局部的错误条件检测，使用严格模式的好处是可以提早知道代码中的存在的错误，及时捕获一些可能导致编程错误的ECMAScript行为。在开发中使用严格模式能帮助我们早发现错误。  

### 判断数据类型  
- `typeof` 可以识别简单基本类型值，但对于复合类型(Object,Array,Function)却只能识别Function。

- `instanceof` 的作用是判断实例对象是否为构造函数的实例，实际上判断的是实例对象的__proto__属性与构造函数的prototype属性是否指向同一引用； instanceof找到的是实例在原型链中所有的构造函数，不容易找到直接创建实例的构造函数；

- `constructor` 作用是返回实例的构造函数，即返回创建此对象的函数的引用；找到的是构造函数只有一个，就是直接创建这个实例的构造函数，所以用constructor找实例的构造函数更严谨。`undefined`和`null`没有`constructor`属性

- `Object.prototype.toString.call()`;

### new操作符具体干了什么  
- 创建一个空对象，并且this指向该对象，同时还继承了该函数的原型
- 属性和方法被加入到this引用的对象中
- 新创建的对象由this所引用，并且最后隐式返回this

### 对this指向的理解
- this根据使用的环境有不同的指向。
- 在函数中使用，this指向window，this指向是根据函数定义时环境而不是调用时的环境。
- 通过new 函数，this指向new出来的对象，如果直接调用函数就和普通函数一样，指向window。
- 对象方法中调用this指向对象本身
- 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window
- 箭头函数中this指向父级作用域；
- 在`export`模块中,`this`是`undefined`，代码是在模块作用域之中运行，而不是在全局作用域中运行。模块内部的顶层变量是外部不可见的，在模块中使用this是无意义的。
- this可以被`call`/`apply`/`bind`改变指向。

### 数组去重的方法
- `indexOf()` 方法，定义一个新数组，遍历要去重的数组，使用 indexOf() 判断新数组中没有该条数据时，将数据加入新数组
``` js
var arr = [1,2,34,5,4,5,3]
var newArr = []
for(var i=0;i<arr.length;i++) {
  if(newArr.indexOf(arr[i]) === -1) {
    newArr.push(arr[i])
  }
}
```

- ES6 去重，利用 Set 构造函数
``` js
var arr = [1,2,34,5,4,5,3]
var newArr = Array.from(new Set(arr))
```

- 双重循环，外层从 0 到 arr.length，内层循环从 i+1 到 arr.length，将没有重复的值放入新数组
``` js
var arr = [1,2,34,5,4,5,3]
var newArr = []
for(var i=0;i<arr.length;i++) {
  for(var j=i+1;j<arr.length;j++) {
    if(arr[i] === arr[j]) {
      ++i
    }
  }
  newArr.push(arr[i])
}
```

- 数组递归去重，先排序，然后从最后一个开始比较，遇到相同就删掉
``` js
var arr = [1,2,34,5,4,5,3]
var newArr = []
arr.sort(function(a,b) {
  return a-b;
})
function loop(index) {
  if(index>=1) {
    if(arr[index] === arr[index-1]) {
      arr.splice(index,1)
    }
    loop(index - 1)
  }
}
loop(arr.length)
```

### apply、call、bind
- apply,call,bind都是用来改变this指向的
- apply和call会让当前函数立即执行，而bind会返回一个函数，后续需要的时候调用
- 如果使用 apply 或 call ，那么 this 指向它们的第一个参数，apply 的第二个参数是一个数组

### 判断对象内容是否相等
``` js
var obj = {a: 1,b: 2}
var obj2 = {a: 1,b: 2}
JSON.stringify(obj) === JSON.stringify(obj2) // ture
```

### 如何解决跨域问题  
首先了解下浏览器的同源策略 同源策略`SOP（Same origin policy）`是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源

解决跨域的方式：  
- 通过jsonp
``` js
var script = document.createElement('script');
script.type = 'text/javascript';

// 传参并指定回调执行函数为onBack
script.src = 'http://xxx:8080/login?user=admin&callback=onBack';
document.head.appendChild(script);

// 回调执行函数
function onBack(res) {
    alert(JSON.stringify(res));
}
```

- document.domain + iframe跨域
:::tip 
此方案仅限主域相同，子域不同的跨域应用场景
:::
父窗口
``` html
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
```

子窗口
``` js
document.domain = 'domain.com';
// 获取父窗口中变量
alert('get js data from parent ---> ' + window.parent.user);
```

- CORS 跨域资源共享 Cross-Origin Resource Sharing
CORS允许浏览器向跨域服务器发出XMLHttpRequest请求，突破了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持，目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。在请求头里指定Access-Control-Allow-Origin所允许原始的请求路径

- HTML5跨文档通信API window.postMessage
- nginx代理跨域
- nodejs中间件代理跨域

### JS异步加载的方式  
- 在`<script>`标签中添加`async`属性，async是HTML5中新增的属性
- `ajax`
- `async`/`await` 
`async` 函数就是 `Generator` 函数的语法糖。`async` 函数返回一个 `Promise` 对象，可以使用 then 方法添加回调函数。  
`await` 也是一个修饰符，await 关键字 只能放在 `async` 函数内部， await关键字的作用 就是获取 `Promise`中返回的内容， 获取的是`Promise`函数中resolve或者reject的值。  
如果await 后面并不是一个Promise的返回值，则会按照同步程序返回值处理。
await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。

- 使用 Promise 对象

### 模块化开发  
- 立即执行函数,不暴露私有成员

### ES6常用方法：
ES6是继ES5之后的一次改进，相对于ES5更加简洁，ES6新增了一些特性，
- let，const  
  - 两个都有块级作用域，使用let一定要声明，const声明后必须赋值，ES5中没有块级作用域，使用var有变量提升
  - var声明变量可以重复声明，var会与window映射（会挂一个属性）

- 箭头函数  
  - 用箭头函数，this指向父级作用域，不再指向window
  - 不能使用arguments对象，可以使用默认参数代替
  - 不能用作构造函数，就是说不能使用new命令

- 模板字符串  
  - 将表达式前染字符串中拼接，使用`${}`
  - 使用反引号（`）标识，定义多行字符串不用使用加号连接

- 解构赋值 
  - 数组解构赋值，在绑定值时根据属性下标进行匹配。赋值操作符两边的解构要一致才能正确赋值，如果匹配不成功，取值为undefined。可以设置默认值。
  - 对象解构赋值，在绑定值时根据属性 key 进行匹配。赋值运算符两边的解构必须一致才能正确赋值。

- `for of` 循环
`for of`可以遍历数组、Set、Map结构，类数组对象，对象，以及字符串

- `import`、`export`/导入导出
ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用。

- `Set`和`Map`的区别
  - Set（集合）用于数据重组，Map（映射）用于数据存储
  - Set结构类似数组，所有的数据都是唯一的，没有重复的值。它本身是个构造函数。
  - Set可以遍历，方法有`add`,`delete`,`has`
  - Map本质是键值对的集合，类似集合
  - 可以遍历，可以跟各种数据格式转换

- `...`展开运算符
可以将数组或对象中的值展开；还可以将多个值收集为一个变量

- `class` 类
例：
``` js
// ES5 定义类
function Person(name) {
  this.name = name;
}
Person.prototype.getName = function() {
  return this.name;
}

// ES6 定义类
class Person {
  constructor(name) {
    this.name = name;
  }
  getName() {
    return this.name;
  }
}

// 调用方式一样
new Person('zhangsan');
```

 - 用ES6定义的`class`的方法，定义再原型对象上。定义在原型对象上的方法是不可枚举的。
 - ES6类和模块是严格模式下的，不存在变量提升
 - 类的继承，子类必须在构造函数中调用`super()`,这样才有this对象，因为this是从父类继承的。子类中要调用父类的方法，用`super`关键字指代父类。
 - ES6可以定义类的静态属性和静态方法，静态的意思是这个属性或方法不会被实例继承、不需要实例化就可以直接使用。在ES6类中，方法名前面加上`static`就表示这个方法是静态方法；静态属性按照ES5的方式定义
``` js
// ES5 写法
Person.total = 0; //静态属性
Person.counter = function() {  //静态方法
  return this.total++;
}

// ES6 写法
class Person {
  constructor() {

  }
  static counter() {
    return this.total++;
  }
}

Person.total = 10; //静态属性

// 使用静态方法
Person.counter()
```

- Promise构造函数是同步执行还是异步执行，那么 then 方法呢？

Promise 构造函数是同步执行的，then方法是异步执行的

- Promise有几种状态，什么时候会进入catch？
三种状态： `pending`(初始状态),`fulfilled`(成功的操作),`reject`(失败的操作)  
两个过程：`pending` -> `fulfilled`,`pending`->`rejected`
当`pending`为`rejected`时，会进入`catch`

### 对Promise的理解
- 通过Promise的原型方法`then`拿到返回值
- Promise链式写法，`then`式链式写法本质是一直往下传递返回一个新的Promise，也就是说`then`在下一步接收的是上一步返回的Promise
- `catch`是针对整个链式写法的错误捕获的，而`then`第二个回调函数是针对上一个Promise的。
- 链式中任何一个环节出现问题，都会被`catch`到，同时某个环节后面的代码就不会执行了。
- `Promise.all`,输出一个数组，相当于把`all`方法里面的`Promise`并行执行。

### `setTimeout`、`Promise`、`async`/`await`的区别
- 事件循环中分为宏任务队列和微任务队列
- 其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行
- Promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行
- async函数表示函数里面可能会有异步方法，await后面跟一个表达式
- async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行


### 如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗

不可以，created/componentWillMount 时，还未挂载，代码仍然在服务器中执行，此时没有浏览器环境，因此此时访问 localStorage 将会报错。

### Apache、Tomcat 和 Nginx 的区别
1. 都可以做Web服务器，对外服务

2. Apache、Nginx 都是Web Server，而Apache Tomcat是应用（Java）服务器，它是一个 servlet （JSP也翻译成Servlet）容器。可以认为是Apache的扩展，但是可以独立于Apache运行。
 
3. Nginx 和 Apache 只是Web服务器，可以简单的理解为只能提供HTML静态文件服务器。php等动态语言的支持需要靠扩展。Tomcat 具有 Nginx 和 Apache 的静态文件服务，同时具有 JSP 的解析功能

[参考](https://www.cnblogs.com/kaleidoscope/p/9579586.html)

### Webpack 构建流程
Webpack 构建运行在node.js环境，它的配置文件遵循 Common.js 规范，Webpack.config.js导出一个Object对象（或者导出一个Function，或者导出一个Promise函数，还可以导出一个数组包含多份配置）。Webpack从入口文件开始，识别出源码中模块化导入语句，递归找出它们的依赖，然后把入口文件和所有依赖打包到一个单独的文件中（chunk），这就是所谓的模块化打包。支持ES6、Common.js、AMD等模块化语法。

#### entry
入口，可以是单个或多个。指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。

#### output
出口，output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 `./dist`。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。

#### loader
loader 用于对模块的源代码进行转换。loader 可以使你在 import 或"加载"模块时预处理文件。loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript），loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块。在module.rules 数组中进行配置，它用于告诉Webpack使用哪些loader去加载和转换。

#### plugin
plugin 用于扩展Webpack功能，插件目的在于解决 loader 无法实现的其他事。实现原理是在构建流程里注入钩子函数。在 plugins 数组中进行配置。

[参考](https://www.jianshu.com/p/5ded519fc1e7)

双向数据绑定原理，自己实现双向数据绑定

promise、async,await,setTimeout原理、执行顺序

DOM和BOM的区别

自己实现下拉刷新、上拉加载

JavaScript 面向对象编程

apply，call，bind的区别，为什么他们可以实现改变this

ES6语法

学习Vue的实现原理，源码理解

如何理解虚拟DOM

服务端渲染vue 

你觉得Vue有哪些缺点，是否满足所有的业务需求

jQuery load 和 get 的区别

GIS相关技术

设计模型

前端自动化部署
 

### 封装过axios吗，对请求、错误流程统一管理，实现axios自动重连
- 利用axios的拦截器处理请求和响应，
- axios.interceptors.request.use()
- axios.interceptors.response.use()
- 在请求拦截器中设置请求方法，token，登录过期等操作
- 在响应拦截器中设置请求超时、错误处理、更新状态等操作
- 在响应拦截和catch捕获中根据状态码设置自动重连等异常流程

### 为什么浏览器会有同源策略
- 两个页面地址中协议、域名、端口一致，表示同源
- 设置同源策略的主要目的是为了安全，如果没有同源限制，在浏览器中cookie等其他数据就可以任意读取，不同域下的DOM操作，ajax任意请求其他网站的数据，包含隐私数据。


### js数组遍历（for in ,for of ,map,foreach,filter）的区别
- `for in`，更适合遍历对象，尽量不使用 for in 遍历数组，
 - `for in` 遍历数组时，索引实际上是字符串类型的数字，不能进行运算
 - 遍历的顺序可能不是数组内部的顺序，for in 会遍历数组内所有可枚举的属性，包括原型上的属性和方法
 - `for in` 遍历对象时，index为该对象的键值，`Object[index]`能取到每个键对应的值

- `forEach`，它会遍历数组里每个元素，不会生成新的数组，也不会改变原数组，没有返回值，return 在其中是无效的，回调函数接收三个值：元素、索引、数组，主要用于对数组自身的处理；

当数组中元素是值类型，forEach不会改变数组，当是引用类型，则可以改变数组；不支持链式调用

- `map`，和 forEach 类似，map 即“映射”，map会遍历数组的每一项，有返回值，会返回一个新的数组，但是保持原始数组不变；map 中每个元素都要执行相应的回调函数，所以必须要有 return

- `filter`，是过滤的意思，可以返回一个新的数组，它会把满足条件的元素拿出来形成一个新的数组，适合做数组去重等操作

- `sort` ，用于对数组的元素进行排序。排序的属性可以是字母或数字，并按升序或降序；sort 会直接改变原始数组；

- `some` ，用于检查数组中是否有符合条件的选项，返回 Boolean 类型，只要有一个满足就返回 true，并停止循环

- `every`，返回 Boolean 类型，用于检测数组中的每一项是否都满足条件，只要都满足才返回 true，如果说 `some` 是 `||` 判断，那 `every` 是 `&&` 判断，用于检测数组中的每一项是否都满足条件，只要都满足才返回 true

- `find`， 遍历数组，只要有一个满足条件就返回当前元素，并停止遍历

- `findIndex`， 遍历数组，只要有一个满足条件就返回当前元素的索引，并停止遍历

### 给一个数组去重
- 使用 `new Set()` 构造函数
`Array.from(new Set([1,2,3,4,5,5]))`

### 判断当前数组里是否有某个元素，并返回该元素
- 使用数组的 find 方法，可是 IE11 和更早的版本不支持

### 判定当前数组里是否有某个元素，并把它去除
- 使用 filter 方法，过滤掉不满足条件的元素

### 内存溢出的情况有哪些

### 深浅拷贝
- 浅拷贝
  - Object.assign
  - `...`展开运算符

- 深拷贝
  - JSON.parse(JSON.stringify(obj))

### 防抖/节流
- 防抖，在某个时间期限内，事件处理函数只执行一次。

在第一次触发事件时，不立即执行函数，而是给一个期限值，在期限值内没有触发事件，就执行函数；期限值内如果再次触发事件，则取消当前计时，重新开始计时
``` js
/**
 * fn [Function] 需要防抖的函数
 * delay [Number] 毫秒，防抖期限值
*/
function debounce(fn,delay = 1000) {
  let timer = null;
  return function() {
    if(timer) {
      clearTimout(timer)
    }
    timer = setTimeout(fn,delay)
  }
}

// 使用
window.onscroll = debounce(() => {
  var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
  console.log('滚动条位置：' + scrollTop);
})
```

- 节流，在短时间内大量触发同一事件，在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这个时间才会重新生效。
``` js
function throttle(fn,delay) {
  let valid = true
  return function() {
    if(!valid) return false

    valid = false
    setTimeout(() => {
      fn()
      valid = true
    }, delay)
  }
}

// 节流函数还有其他实现方式
// 不使用 setTimeout，把状态位换成时间戳，然后判断时间戳差值是否大于指定间隔时间来判断
// 也可以判断 setTimeout 的返回值，判断当前定时器是否存在，如果存在，表示还在冷却，并在执行完 fn 之后清除定时器，表示激活

// 使用
window.onscroll = throttle(() => {
  var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
  console.log('滚动条位置：' + scrollTop);
}, 1000)
```

## Vue
### 谈谈对MVVM开发模式的理解  
MVVM分为Model、View、ViewModel  
Model 代表数据模型，数据和业务逻辑都在Model层中定义
View 代表UI视图，负责数据展示  
ViewModel 负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作。Model和View并无直接关联，而是通过ViewModel来进行联系，Model和ViewModel之间有着双向数据绑定的关系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。  
这种模式实现了Model和View的数据同步，因此只需要专注对数据的维护操作，而不需要自己操作dom

### Vue监听某个属性值的变化  
watch、computed

### Vue 中 methods,computed 和 watch 的区别，以及适用场景
**methods**  
methods中是用来定义函数的，需要手动去执行，而不像computed,watch一样，属性变化时自动执行。

**computed：通过属性计算得来的属性**
- computed内部的函数在调用时不加`()`
- computed依赖vm中data的属性变化而变化，data中属性没有改变的时候，当前函数不会执行
- computed中函数必须用return返回
- 在computed中不用data属性进行赋值操作。如果进行了赋值操作，data属性发生变化，从而触发computed中的函数，形成死循环。
- 当computed中函数所依赖的属性没有发生改变，那调用当前函数时会从函数中读取

**watch：属性监听**
- watch中函数名称必须要和data中属性名一致，当data中属性发生改变时，watch中的函数会执行
- watch中的函数有两个参数，前者是新值，后者是旧值
- watch中函数是不需要调用的
- watch只会监听数据的值是否发生改变，而不去监听数据地址是否发生变化。watch中能监听属性、对象的变化，watch要监听引用类型的数据变化，要进行深度监听。  
"obj.name"(){}------如果obj的属性太多，这种方法的效率很低 
obj:{handler(newVal){},deep:true}------用handler+deep的方式进行深度监听。

**区别**
1. 功能上，computed是计算属性，watch是监听一个值的变化，然后执行对应的回调
2. 是否调用缓存：computed中属性的值没有发生变化，从缓存中取；watch在每次监听的值发生变化的时候都会执行回调
3. 是否调用return：computed中函数必须使用return返回；watch中函数不是必须要用return
4. computed不支持异步，watch支持异步
5. 当模板中的某个值需要通过一个或多个数据计算得来时，就可以使用计算属性，计算属性的函数不接受参数；监听属性主要监听某个值发生变化后，对新值去进行逻辑处理。
6. 当且仅当计算属性依赖的data改变时才会自动计算

### Vue中 $on 和 $emit的理解
兄弟组件之间通信，一个组件内的事件触发同级组件内的方法，这个时候就可以用到 `$on` 和 `$emit`.  
`$on`  
1. 语法`$on('事件名',callback)` ，callback回调,$emit要传送的数据
2. 监听当前实例上自定义事件
::: tip 提示
`$on` 和 `$emit` 事件必须在一个公共的实例上，所以可以使用一个空的Vue实例作为中央事件总线。
:::

### Vue中有哪些指令  
`v-html,v-text,v-bind,v-on,v-if,v-show,v-for,v-model`

**实现原理**


### v-if和v-show的区别  
v-show只控制元素的显示与隐藏，将display属性在block和none之间切换；v-if会控制DOM节点的存在与否。
当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；只需要一次显示与隐藏的时候，使用v-if更合理。

### Vue的响应原理  
当一个Vue实例创建时，vue会遍历data选项的属性，用Object.ddfineProperty将他们转为setter/getter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。  
每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

### Vue检测属性的变化  
受现代Javascript的限制，Vue无法检测到对象属性的添加或删除。由于Vue会在初始化实例时对属性执行getter/setter转化，所以属性必须在data对象上存在才能让Vue将他转换为响应式的。对于已经创建的实例，Vue不允许动态添加根级的响应式属性，但是可以使用Vue.set(object,propertyName,value)方法向嵌套对象添加响应式属性。  
还可以使用vm.$set实例方法，这是全局Vue.set方法的别名

### 在Vue中在组件内部实现一个双向数据绑定的例子？  
假设有一个输入框组件，用户输入时，同步父组件页面中数据。  
父组件通过props传值给子组件，子组件通过$emit来通知父组件修改相应的props值  
父组件中做了两件事，一是给子组件传入props，二是监听input事件并同步自己的属性。
v-model会帮我们完成上面两步操作

### Vue给data中的对象属性添加一个新的属性  
给data中的对象添加新属性，视图不会刷新。原因是在Vue实例创建时，未声明的属性不会被Vue转换为响应式的属性，不会触发视图更新，需要使用Vue的全局api $set(),手动的把新增属性处理成一个响应式属性

### localstorage和vuex的区别
localstorage以文件的形式进行存储，vuex属于js，内容存储在内存中，vuex是用于状态管理，用作不同组件之间的通信，使用单向数据流方式进行管理

### 单向数据和双向数据管理的区别
- 数据流，表示数据的流向，也就是说的数据传递
- 单向数据流就是说数据向单一方向传输，对应Vue来说，组件之间数据传递具有单向数据流这样的特性
- 双向数据流是指，数据模型（Module）和视图（View）之间的双向绑定，当数据发生变化时，页面自动更新

### 自己实现一个双向数据绑定
1. 监听元素的事件
2. 利用Object.defineProperty
``` js
function defineReactive(data, key, val) {
  Object.defineProperty(data,key, {
    enumerable: true, // 可枚举
    configurable: false, // 不能再define
    get: function() {
      return val;
    },
    set: function(newVal) {
      val = newVal
    }
  }
}
```

### vue-router实现原理
vue-router 通过 Hash 和 History 接口，两种方式实现前端路由，更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：

- 利用URL中的 hash（#）
- 利用HTML5的 History 接口

在 vue-router 中，通过mode这个参数控制路由的实现模式，默认采用的是 hash。程序根据选择的mode类型，创建不同的history对象（HashHistory、HTML5 History 或 AbstractHistory）

如果浏览器不支持 history，就采用hash模式，如果在node环境，采用abstract

- HashHistory
hash（“#”）符号的本来作用是加在URL中指示网页中的位置，#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。有以下特点：
  - hash虽然出现在URL中，但是不会包含在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面。
  - 可以为hash的改变添加监听函数，`window.addEventListener('hashchange',Function,false)`
  - 每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录

HashHistory 替换路由主要有两种方法：
  - `HashHistory.push()`,将新路由添加到浏览器访问历史的栈顶
  - `HashHistory.replace()`,替换掉当前的路由

- HTML5 History
History interface是浏览器历史记录栈提供的接口，通过back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。

从HTML5开始，History 提供两个新方法：`pushState()`,`replaceState()`
``` js
window.history.pushState(stateObject, title, URL)
window.history.replaceState(stateObject, title, URL)

// stateObject: 当浏览器跳转到新的状态时，将触发popState事件，该事件将携带这个stateObject参数的副本
// title: 所添加记录的标题
// URL: 所添加记录的URL
```

- 两种模型比较
为了美观，推荐使用 history 模式，不过 history 模式存在一个问题
  - pushState 设置的URL可以是与当前URL同源的任意URL；hash 只可修改 # 后面的部分，所以只可设置与当前同文档的URL
  - pushState 设置的心URL可以和当前URL一模一样，记录也会加入栈中；hash 设置的新值必须与原来的不一样才会触发记录添加到栈中
  - pushState 通过 stateObject 可以添加任意类型的数据到记录中；hash 只能添加短字符串
  - pushState 可额外设置title属性供后续使用

- history 模型存在的一个问题
对应单页面应用，如果用户直接在地址栏输入地址并回车或刷新页面，hash 模式仅改变 hash 部分的内容， 而hash不会包含在HTTP请求中。而 history 模式会将URL修改得和正常的URL请求一样，如果后端没有配置对应的路由，会报404。官方的解决方法是在服务端增加一个配置文件，如果URL匹配不到静态资源，则返回同一个index.html,这样服务端就不会返回404页面，因为对所有的路由都返回index.html。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。

[参考: 从vue-router看前端路由的两种实现](https://zhuanlan.zhihu.com/p/27588422)

### 负载均衡
多台服务器共同合作，不让其中某一台或几台超额工作，发挥服务器的最大作用

- HTTP重定向负载均衡：调度者根据策略选择器以302响应请求，缺点只有第一次有效果，后续操作维持在该服务器

- DNS负载均衡：解析域名时，访问多个IP服务器中的一个（可监控性较弱）

- 反向代理负载均衡：访问统一服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大

### 正向代理和反向代理的区别
- 正向代理类似一个跳板机，代理访问外部资源，
- 正向代理，只用域代理内部网络对Internet的连接请求，客户机必须指定代理服务器，并将本来要直接发生到web服务器上的http请求发送到代理服务器上 
- 正向代理是客户端代理，代理客户端，服务器不知道实际发起请求的客户端

- 反向代理，指以代理服务器来接受Internet的连接请求，然后将请求转发到内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外表现为一个服务器。
- 反向代理是服务端代理，代理服务器，客户端不知道实际提供服务的服务端

::: tip 例
例如要去访问谷歌网站，我们直接访问不通，这个时候找一个代理服务器为我们服务，我们通过代理服务器去访问

正向代理用途：
  - 访问原本无法访问的资源
  - 可以做缓存，可以加速访问
:::

### delete和Vue.delete删除数组的区别  
delete只是把删除的元素变成 empty/undefined ，元素的键值还是不变  
Vue.delete直接删除了数组 改变了数组的键值。

### 优化SPA应用首屏加载速度慢的问题  
- 将公用的JS库通过script标签外部引用，减小app.bundel的大小，让浏览器并行下载资源，提高下载速度
- 在配置路由时，页面和组件使用懒加载方式引入，进一步缩小app.bundel的体积，在调用某个组件时再加载对应的js文件
- 加个首屏loading，提升用户体验

### 优化网站性能  
- 减少HTTP请求数量
- CSS Sprites（CSS 精灵），将多张图片合并成一张达到减少HTTP请求的方案，通过CSS background属性来使用。这种方法还可以减少图片总字节数
- 合并CSS和JS文件，通过各种打包工具
- 采用lazLoad（懒加载），控制网页的内容一开始不加载，等到需要的时候立即加载出来
- 控制资源文件加载优先级
- 利用浏览器缓存
- 减少重排（Reflow），基本原理：重排是 DOM 的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效
- 减少DOM操作
- 图标使用iconfont替换

### 减少重排，对比重排与重绘
重绘（repaint）：当元素的外观属性发生变化，即元素的颜色，背景色发生改变但没有影响到dom树的位置改变的时候，会触发重绘；

重排（reflow）：当页面内的元素尺寸发生了变化，导致部分或者全部DOM树，渲染树需要重新更新，会触发重排， 重排又称为回流；

一般情况下，页面的重排必定会导致重绘，但重绘不一定会导致重排。

触发重排的条件，具体来说有以下几点：
1.页面渲染初始化；
2.添加与删除DOM元素；
3.元素位置的改变，或者使用动画；
4.元素的尺寸发生改变；
5.浏览器窗口尺寸的变化（resize事件发生时）；
6.文本内容被改变或者图片被不同尺寸的图片替换；
7.读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)

一般在我们的开发过程中，当DOM元素的操作不可避免时， 我们可以通过以下方式来尽量减少重绘与重排，重点是减少重排，主要的思路是， 将多次的DOM 操作合并为一次，或者使需要被操作的元素脱离文档流以减少浏览器重绘与重排的次数，下面的这些操作都是通过减少重排重绘来实现性能优化的：

1.元素的多次样式修改合并成一次修改；
2.如需进行对DOM节点进行多次操作，先将其脱离文本流之后再进行多次操作；
3.table布局的渲染与普通DOM节点的操作相比，性能消耗更大，如果可以，尽量减少table布局的使用；
4.缓存常用的布局信息；
5.兼容IE时减少使用hover；
6.动画使用window.requestAnimationFrame()，window.requestAnimationFrame() 这两个方法调节重新渲染；
7.使用虚拟dom脚本库，例如react或者snabbdom等。

### 网页从输入网址到渲染完成经历了哪些过程  
  大致分为7步：  
  1. 输入网址
  2. 发送到DNS服务器，并获取域名对应的web服务器对应的IP地址
  3. 与WEB服务器建立TCP连接
  4. 浏览器想WEB服务器发送HTTP请求
  5. WEB服务器响应请求，并返回指定URL的数据（或错误信息，或重定向的新的URL地址）
  6. 浏览器下载WEB服务器返回的数据及解析HTML源文件
  7. 生成DOM树，解析CSS和JS，渲染页面，直到显示完成

### jQuery获取的DOM对象和原生的DOM对象有何区别  
原生JS获取的DOM是一个对象，jQuery对象就是一个数组对象，他们是不同的对象，类型不等价
- 原生DOM对象转jQuery对象：
``` js
var box= document.getElementById('box');
var $box = $(box);
```

- jQuery对象转原生DOM对象：
``` js
var $box = $('#box');
var box = $box[0];
```
### Vue生命周期  
`beforeCreate`  -------创建前  
`created`       -------创建后  
`beforeMount`   -------挂载前  
`mounted`       -------挂载后  
`beforeUpdate`  -------更新前  
`updated`       -------更新后  
`beforeDestroy` -------销毁前  
`destroyed`     -------销毁后  

### created 和 mounted 区别  
`beforeCreate`: el和data并未初始化
`created`: 完成了data数据的初始化，el没有
`beforeMount`: 完成了el和data初始化
`mounted`: 完成挂载

###  插槽 slot  
- 单个插槽（默认插槽）
- 具名插槽
- 作用域插槽

### Vue keep-alive以及activated，deactivated生命周期
`<keep-alive>`包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和`<transition>`相似，`<keep-alive>` 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。

当组件在`<keep-alive>`内被切换，`activated` 和 `deactivated` 这两个生命周期钩子函数将会被对应执行。

### 实现keep-alive页面前进数据刷新，后退缓存
- 方案1：

1. 在`App.vue`中根据route中属性判断
``` html
<keep-alive>
  <!-- 会被缓存的视图组件 -->
  <router-view v-if="$route.meta.keepAlive" />
</keep-alive>

<!-- 会被缓存的视图组件 -->
<router-view v-if="!$route.meta.keepAlive" />
```

2. 在router/index.js中需要缓存的组件的元数据中加上keepAlive属性
``` js
{
  path: '/index',
  name: 'index',
  component: () => import('../views/index.vue'),
  meta: {
    keepAlive: true
  }
}
```

3. 在要缓存的页面B的beforeRouteLeave((to,from,next)=>{next()})路由钩子函数中根据条件设置to.meta.keepAlive

- 方案2：在`<keep-alive>`中增加 `include`和 `exclude` 属性，include代表要缓存，exclude代表非缓存

### axios 封装，实现自动登录


### vue-router 路由跳转方式有哪些
- 声明式 `<router-link to="path" />`,浏览器解析时会解析成a标签

- 编程式  `this.$router.push('path')`,常用于路由传参

### vue-router传参
以js方式为例，  
- query 方式
  - 传参：`this.$router.push({name: 'home',query: {id:'1'}})`
  - 取参：`this.$route.query.id`
  - query传递对象 (类似get,url后面会显示参数) JSON.stringify(obj) 转一下

- parmas 方式,类似post
  - 传参：`this.$router.push({name: 'home',params: {id: '1'}})`
  - 取参：`this.$route.params.id`

- 区别
query类似 get，跳转之后页面 url后面会拼接参数
post，跳转之后页面 url后面不会拼接参数，但是刷新页面参数会消失。

### Vue router 嵌套路由如何定义，使用场景
router.js中，在路由对象的children中定义，HTML中嵌套`<router-view>`
使用场景：路由有父子关系的，使用嵌套路由比较好。

### Vue常用框架
Element-ui,Vant,Ant-Design

## 小程序
### tabBar和普通页面之间的跳转
跳转tabBar:  
  - js中使用`wx.switchTab({url: '../pages/index/index'})`
  - 标签中使用`<navigator>`标签，需要设置`open-type="switchTab"`

应用内页面跳转:  
  - js中用wx.navigateTo()跳转,`wx.navigateTo({url: '/pages/mine/mine'})`
  - 标签中使用`<navigator>`标签

### 自定义tabBar
  - 每个模拟的tabbar页面都需要引入自定义tabbar组件
  - 跳转使用`wx.redirectTo()`,只能跳转普通页面

### 小程序页面传参
  - 普通页面通过url传参，wx.switchTab跳转页面，url不能带参，解决办法使用wx.reLaunch方法
  - 利用本地缓存传参
  - 使用全局变量

### H5适配解决方案
- 引入淘宝开源的可伸缩布局，[lib-flexilbe](https://github.com/amfe/lib-flexible)

淘宝的其实也和viewport的有点像，但是它主要是根据设备设备像素比设置scale的值，保持视口device-width始终等于设备物理像素，屏幕大小动态计算根字体大小，具体是将屏幕划分为10等分。
- 使用viewport，[链接](http://www.cnblogs.com/2050/p/3877280.html)
- 使用`@midea`媒体查询属性,动态设置根部html字体大小，配合rem单位
- 动态vieweport 和 rem 适配

### 原生APP和H5的交互
APP 和 H5 交互，本质上就是两种调用：
1. App 调用 H5 的代码
因为 App 是宿主，可以直接访问H5，在 H5 中暴露一些全局对象或方法，然后在原生中调用这些对象或方法

2. H5 调用 App 的代码
H5 不能 直接访问宿主 APP，所以要复杂一些，有两种常用的调用方式：  
 - 由 APP 向 H5 注入一个全局js对象，然后在 H5 直接访问这个对象
 - 由 H5 发起一个自定义协议请求，APP 拦截这个URL请求，再由 APP 调用 H5 中的回调
